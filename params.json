{"name":"Landz","tagline":"a foundation, for the pleasure of backend engineering, with Java 8","body":"Landz: set down a solid base for next three years' Java backend\r\n===============================================================\r\n\r\nThanks for all coming in. This is the first article of the Landz project. I firstly put it into the [NH](https://news.ycombinator.com/), where I thought, Landz may be more welcome for the brave to change. But with continuing to go ahead, the Java or wider community will have the message.\r\n\r\n## TL;DR\r\n\r\n\r\n## Basic Philosophies\r\n\r\nTwo most significant characteristics are: **conciseness** and **high performance**. \r\n\r\nIn these years' experience of software engineering, I've always seen too many developers have wasted too many times to repeat the same mistakes one by one. One common point is that they always use some stupid monster frameworks, no matter open-souce or commerical. These frameworks usually has a \"simple\" \"box\" for binding your business into their \"workflow\". The users often do not understand or control the frameworks, and the reason that they use these frameworks is just that \"it is said other people use them\". And even the developers of these framework do not understand or control the frameworks in that these monsters are developed by monster teams, and have been out of themself's control.\r\n\r\nAnother interesting philosophy of Landz is:\r\n\r\n> Software has bugs always.\r\n\r\nNote this also applies to Landz itself. Then, the question comes out: how do we do if the \"workflow\" broken?\r\nThe answer is that your business become broken now. More, if you can not fix your broken parts soon, then a few crackers may take use of it. This may highly even damages the business of the clients of your business.\r\n\r\n**Conciseness** is one most thing Landz want to bring into our older broken Java community. Landz with conciseness helps the users to understand and control the \"Landz\" themself other than hiding itself via any maigics. Landz believes the conciseness and \"no-maigic\" give the full control over and then best values to your bussiness. Say goodbye to any stupid monsters.\r\n\r\n**High performance** is another concern of Landz.  Landz digs out the maximum capacity of system and hardware on top of modern commodity server and modern Java. The existed frameworks often focus on the features rathter than performance. Instead, Landz desires bare metal performance. Start-ups usually choose simple solutions for fast prototyping. Then, they find the solution can not support their fast-grown business. They change to more matural platform, like Java. The is the stories for many start-ups. We also believe there is no essential conflict betweem fast and performance, which are both explored by Landz in core level. To use the Landz from your first day of starting up makes your wasted minimized and life easier:)\r\n\r\nSometimes, the above two characteristics are not always exactly matched up with each other. Landz trys to find a trade-off between two. When it is found that we make some mistake in the two, we drop it. Yes, we will not keep mistakes for the stupid compatibility(of course, we will consider the existed Landz's users).\r\n\r\nFor clear emphasis, particularly the following statements are **not the goals of Landz**:\r\n* **compliant with any specification**.\r\nthis does not mean Landz do not implement any specification. But it means Landz keeps his independent judgement to these specifications. \r\n\r\n* **promote any style.**\r\nYou may think Landz should be in reactive or FP style. But it is not the goal of Landz. The style does not change the bare metal execution. Whether one style is easier to accept than others matters individually. Style is a thing that would be outdated easily. As a foundation, it is hoped the Landz can be welcome to the wider crowd with different favors. \r\n\r\n* **polyglot for all languages**.\r\nIn fact, Landz itself is in the land of Java. As we known, there are many languages on JVM which try to resolve some problems in the enterpise(backend) Java development. Here, I do not comment on any these languages. What I love the Java language is that it is a kind of C++-- style. We can get the bare metal power from simple language constructs with Java.\r\n\r\nFor some particular modules/components of Landz, Landz may provide some other language supports, like javascript based scripting support for DevOps side modules. But the script language itself will serve as a facade for back Java objects(in that the Java's syntax is still verbose for scripting). Still note, Landz does not want to introduce any magic. Although polyglot is OK on the higher layer of module hierarchy. But this will be based on the result of community efforts. And this is out of the current scope of Landz and its contributors.\r\n\r\nFinally, the above emphases answer another question implicitly: why Landz not contribute to an existed project? Landz has very different world views in software development.\r\n\r\n\r\n## Big Picture\r\n\r\n\r\n\r\n### Java 8\r\n\r\nThe Landz only supports Java 8+. So, if you are not comfortable about the  when you reach here. You may ignore the rest part of this article. And, it is sorry for this.\r\n\r\nYes, the Java 8 has not been officially released now. However, still from these years' experience of one Java veteran, soon we may not live without it.\r\n\r\nThe most impressive thing happened in Java 8, in my eye, is not the numerous new features, but the constructive atmosphere which I seen in the communities around OpenJDK become thriving.\r\n\r\nAll features are decided by some fews and under the secrete table. (And, this still holds to most JavaEE JSRs. this is why JavaEE has killed themselves.) This is just the primary impression of Java to the common Java developers in a long term. The open source of Java indeed changes the evolution of Java. More language designers and implementors come to the community to make themselves being more wise and less stupid.\r\n\r\nLandz has heavily used all the wonderful of Java 8. But I do not repeat any about Java 8 more. Serve yourself by googling.\r\n\r\n\r\n### Z Kernel\r\n\r\nAs its name, z.kernel provide a core must-have of Landz(but still require OpenJDK 8+). The kernel is designed to use as a library. Then, it has three merits:\r\n* any framwork behaviour is not allowed. something like adding agent to your boot command line to enable bytecode magic; \r\n* single jar. Lanz kernel does not rely on 3rd parties library except OpenJDK 8+;(in fact, it can run on OpenJDK 8 Compact profile 1)\r\n* platform-independent.\r\n\r\n\r\n### Concurrency Facilities\r\n\r\nThe frequency match has been come its death end several years ago. Multi-core is the destination for next tens of years(although the number of mainstream x86 cores increase very slowly for kinds of reasons.) That means, we can only scale with bare metal when we have the right concurrency tools.\r\n\r\nWe can not require every developer to understand the JMM or the internal of cache coherence . So, Landz has investigated, provided and continues to improve/add the best concurrency facilities in the world into its kernel for your . \r\n\r\n\r\n#### ITC(Inter-Thread-Communication) Channel\r\n\r\nFirstly, Landz has provided some lock-free queue implementations as ITC mechanism via the Channel API. \r\n\r\nParticularly, HyperLoop (OK, the name ) is a ring buffer backed SPSC(Single-Producer Single-Consumer) or SPMC(Single-Producer Multi-Consumer) queue as a data structure rather than [Disruptor](https://github.com/LMAX-Exchange/disruptor)'s framework style. So the usage of HyperLoop is much easier than the Disruptor. We provide two primitive specializations of HyperLoop to enble extreme performance when your needed. The most important benefit of HyperLoop (and Disruptor) is, that it does not use any full memory fence in cache-coherent-maintianed arch CPU. For x86, it does . But, note, the HyperLoop (and Disruptor) is just excellent for broadcasting style delivery mechanism. So, it is not usual sense \"queue\". Then, further more, the slow consumers block the whole progress of producting/consuming. This limits the usage of such channel. Our HyperLoop has the similiar throughput like Disruptor, but shows 100% or more latency improvement on my i7+linux environment(without affinity pinning. note: Landz provides a great affinity binding DSL in landz.znr.linux.x64).\r\n \r\nGenericMPMCQueue gives a lock-free MPMC(Multi-Producer Multi-Consumer) queue implementation. This implementation is based on Google' [Dmitry Vyukov](http://research.google.com/pubs/DmitryVyukov.html)(now work for Golang concurrency)'s [MPMC queue](http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue). This is only correct MPMC queue implementation I have seen in open source Java currently. It is genernally faster than great Doug Lea's well-known ConcurrentLinkedQueue(Sometimes, it demonstrates 7x fastest than CLQ in one of Landz tests. Note: Landz wins in this testcase because the better memory locality but not due to the GC overloading.) The only cute is that GenericMPMCQueue is not lock-free(Vyukov said this \"not totally lock-free\"), but Doug Lea's CLQ is. GenericMPMCQueue can not guarantee the progress of system at some times but as you seen it works greatly for pratices.(Detail theory needs another article to cover...)\r\n\r\nDifferent to all I reviewed lock-free queue Java implementations, all Landz's implementations has a suit of robost tests to gaurantee the correctness of them. And Landz used the offheap to offer the false-shareing avoidance and memory alignment. In the investigation of existed implementations, I find a barrier bug in Disruptor and an implementation mistake in [Quasar](https://github.com/puniverse/quasar) (to my interesting, Quasar is developed by a company funded by the Y combinator). So, generally, the Landz provides the highest quality which you can use in your production.\r\n\r\nThere are some other implementations of SPSC likes shown in [Nitsan Wakart's blog](http://psy-lob-saw.blogspot.com/). The experiments by me shows that the largest throughput can only be available in a case of special large buffer size(and not match to the comment left by Nitsan himself). For the massive ITC, the total buffer requirement is O(n^2), n is the number of thread. The bloating soon kills the speed of SPSC. And other problem for Nitsan's work is, throughput is not the whole story of his SPSC. Nitsan does not give out a full analysis on the exact means of the value of throughput. Generally, a delay (in latency) will improve the throughput with a large buffer. According to my this statement, the maximum throughput can be achieved with filling an array and exchanging this array object via a non-full-fence SPSC, and the result should be similiar(G+ OP/s). There is some discussions in one recent infoq article on this. OK. This is still not full picture in fact. We leave more details to the future's article. \r\n\r\n\r\n#### Concurrency Constructs\r\n\r\nThe ITC Channel solves the communication problem between different running execution threads. But one problem remains: how to make the program to run on many cores efficiently?\r\n\r\nYes, the programmer is responsible for this. But, does programmer know how to do this efficiently? Java has the Thread. But it is heavy when you spawn much. For modern languages, they go back to a concept - : Erlang/Scala have actor, Go use goroutine.\r\n\r\n[Actor model](http://en.wikipedia.org/wiki/Actor_model) itself does not solves the execution problem. Because how to run actor's processing logic is out of the scope of the model. The true value of actor lies in the message passing idea for concurrency safety. Another implicit difficulty of actor is the message passing protocol desgin. Complex message network may lead to hard-debugging bug.\r\n\r\nCoroutine like lightweight thread provides lightweight way in its appearance. But how to cooperate betweem coroutines is still a problem for programmer. \r\n\r\nI try to see if Landz can mitigate this pain of programmer by use of new concepts and technologies in Java community, like the great working stealing shown in the Java 7 forkjoin. I have not completed the Landz concurrency constructs. If you have ideas about this for Landz should reference or implement, do not hesitate to give your suggestions in the [Landz's group](http://groups.google.com/d/forum/landz).\r\n\r\n\r\n### Offheap Facilities\r\n\r\nJava heap always shows bad stop time when the GC pressure is very high. However, this usually occurs in high performance Java field. One recent [Twitter's blog entry](https://blog.twitter.com/2013/netty-4-at-twitter-reduced-gc-overhead) shows the problem and their effort on this side in [Netty](http://netty.io/) 4.  The common solution is to use the offheap memory area which can be directly accessed by the hotspot unsafe tool (this is why Landz only declares to suppor the hotspot/openJDK) or indirectly like via nio buffer. \r\n\r\nLandz provides one best quasi-general offheap memory allocator - zmalloc. It is designed to have high performance with scalable hardware support(lock-free, space-compact), zero garbage generation and built-in statistics in the pure Java. \r\n\r\nGenerally, people can use object/buffer pool to avoid the complex general malloc technique. But the pool fails in the following cases:\r\n* dynamic size or high throughput\r\nthis is usually for the field of network side buffer \r\n* repeating alloc/free in your pool\r\n* on-heap pool with large szie of objects\r\nthese objects still worsen GC scanning although they are not garbage, but GC does not know this.\r\n\r\nSo, it is good idea to combine both to meet your requirement rather than rely on on single. Note, Landz also provides a fast thread-safe pool for your using.\r\n\r\nOriginally, I investigate the Netty 4's implementation to see if you . The unrestricted usage of keyword \"synchronized\" means Netty's implementation far from high performance field although the author [mentioned](https://blog.twitter.com/2013/netty-4-at-twitter-reduced-gc-overhead) the [jemalloc](http://www.canonware.com/jemalloc/). I am not sure whether Netty compares its implementation to jemalloc but Landz does!:)\r\n\r\nThe implementation idea of zmalloc comes from the public references of several allocator, like tcmalloc, jemalloc and Memcached's allocator and even linux kernel slab allocator etc.. Zmalloc uses chunk/page two-level structure to enable cache. The small size buffer is close to the speed stack allocation. The careful lock-free design combines the thread-local alloc/free speed and cross-thread alloc/free safty. I have heavily jdoc-ed the source of [zmalloc](https://github.com/landz/z-stack). If you have any question about this, jump into [Landz's group](http://groups.google.com/d/forum/landz).\r\n\r\nThis zmalloc deserves a big whole of article to address. So, here, I just post some exciting result:\r\n\r\n>  In the single simple 15 bytes 10000000 times allocation-free tests, zmalloc is 2.6x faster than jemalloc and 40% faster than glibc's malloc(ptmalloc) in allocation; zmalloc is 7.5x faster than jemalloc and 2.7x faster than glibc's malloc(ptmalloc) in de-allocation(free). \r\n\r\n>  In the two-threaded simple 15 bytes 10000000 times allocation(in one thread)-free(in another thread) tests, zmalloc is 1.7x faster than jemalloc and 2.2x faster than glibc's malloc(ptmalloc) in allocation; zmalloc is 2.1x faster than jemalloc and 9% (slightly) faster than glibc's malloc(ptmalloc) in de-allocation(free). \r\n\r\n>  <p> Two points here: \r\n* zmalloc is faster than jemalloc and glibc in these simple tests; \r\n* the glibc' malloc(modern kernel, like now my 3.12.9) has been faster than jemalloc(my 3.5.0) in several aspects in these simple tests;</p>\r\n\r\n>  In the meantime, in single thread test, zmalloc is 20x to 50x faster than Netty's new [ByteBufAllocator](https://blog.twitter.com/2013/netty-4-at-twitter-reduced-gc-overhead). This confirms to the I understand to the Netty's new allocator. But, one unfair thing here is that the Netty only provide a Buffer implementation which is contributed to the garbage collection itself. However, zmalloc just operates on the raw memory address and products zero garbage. \r\n\r\n> For more complex scenarios, I do not further tests. Because the C and Java language constructs and libraries are much different, we can not get more safe conclusion by comparing apple with orange.\r\n\r\nNote, we have solid testcases to guarantee the correctness of zmalloc. And the zmalloc has been heavily used in Landz stack's znr, net and http module. It has provided the excellent results in kinds of scenarios.\r\n\r\nIt must be said that, the access to offheap is dangerous! So, you should double check you keep all of the contracts of offheap area.\r\n\r\nAnd for these reasons, we desgin a high level Buffer inspired by Netty ByteBuf on the top zmalloc. The final choose to the Netty way rather than Java nio Buffer is, that it is find that even [Martin Thompson forget to flip the nio buffer](http://mechanical-sympathy.blogspot.com/2011/12/java-sequential-io-performance.html).\r\n\r\nIn the desgin of Landz's Buffer, we carefully evaluate the Netty ByteBuf's pros and cons. Landz also provide the similiar methods to operate on buffer, but it is allow to interleave different endian bytes. Meantime, Landz takes care of the Buffer's performance to allow optional bound checking and downcast to avoid \"interface juggling\"(many invokeinterface-s in fluent interface pattern). Finally, the Landz's Buffer can be operated in a speed to close to that of raw offheap, and 40%+ faster than that of Netty ByteBuf.(the naming of ByteBuf is really ugly...)\r\n\r\n\r\n### Modularity, DevOps and more\r\n\r\nThe Modularity is a long-waiting feature in Java. But it is definitely [absent from Java 8](http://mreinhold.org/blog/on-the-next-train). I should be one of the most disappointed men. Because, the Oralce has not realized that the Importance of the modularity not only for Java, but also for the software engineering.\r\n\r\nThe built-in package management systems largely contribute to the pop of Ruby and Node.js. I think Java community should have a one. It will be nether complex dynamic OSGI nor stupid-complex boilerplate Maven. \r\n\r\nThe Landz will provide a self-hosted module repo for testing in the near future.\r\n\r\nDevOps is a more aggressive target. It will be great to ship scripting and serviceability runtime. I may choose some existed open source projects as a base in that Landz have not enough resources on all of its interestings.\r\n\r\n\r\n### ZNR and Java FFI\r\n\r\nIn this two days, Charles Nutter of JRuby team has proposed one [Java FFI JEP](https://gist.github.com/headius/8670271) (for Java 9 definitely). \r\n\r\nCombining with Landz's offheap facilities, a layer accessed into Linux core native functions from Java has been constructed in pure Java, called ZNR(landZ Native Runtime). The Amazing thing is that all done in pure Java. This extremely reduces the cost of maintaining without any performance penalty except JNI overhead. In fact, the low plumbing provided by Wayne Meissner is JIT engine. I leave more fun for your exploring. Do not hesitate to ask in the [Landz's group](http://groups.google.com/d/forum/landz) if you have any question.\r\n\r\nAbout the performance, the jffi implementation can be faster than some JNI implementationss(note: the jffi itself is still based on JNI definitely). Like shown in landz, the znr's socket wrappers are even faster than one jboss project' xnio. This is because you do not wrapping yourself code into a JNI to call into the share library such as glibc.\r\n\r\nAll work stems from one disappeared man - Wayne Meissner 's [crazy-ivan](https://github.com/wmeissner/crazy-ivan). I give it a moderate hacking to make it suitable to the target of Landz design. I hope the current JRuby team can maintain the whole hard thing. Then, znr will kept in a thin module after Java 9. If not, Landz will continue to maintain znr independently.\r\n\r\n\r\n### Z Stack for Web Backend\r\n\r\nExcept the kernel, we need a web backend stack, not only to promote Landz itself, but also to enable the Landz \"eating its own dog food\". An direct epoll syscall wrappings have been provided finally based on my reflections and reviews to the current Java shipped NIO implementation(but only for x86-64 linux now). This seems also interesting to the next version of Netty mentioned in [Twitter blog entry](https://blog.twitter.com/2013/netty-4-at-twitter-reduced-gc-overhead). And more, an AIO style of TCP module(landz.net module) is ready(the formal name may be **Proactor**). Because I prefer a composable architecture, rather than the common inherited design. It may need more collections to the requirements to API from the users.\r\n\r\nA whole web backend is huge, Landz is glad to collaborate with other open source projects. Join us at [Landz's group](http://groups.google.com/d/forum/landz).\r\n\r\n## Near or Far Future\r\n\r\nFor much limited resources and natural affinity to open source world, the Landz own stack will be natively built and extremely optimized with the modern Linux kernel + modern x86-64 hardware. The z stack will be ported into x86-64 Windows and MacOS for the purpose of developement but the performance will not be touched. We limit our strength to the power and fun of . This just follows our Landz's philosophies.\r\n\r\nLandz are also interesting to the next 64bit ARM server side hardware. A dedicated support will be provided for it when its coming into the real production. I personally think the first generation of 64bit ARM will be much below the x86 in the side of performance. But it deserves embracing from Landz for a more wide and open ecosystem than x86. That is the Landz's taste! \r\n\r\nLandz continue to review and introduce some goodies in the Java world, like Guava. It is a joy to work with best open source contributions in the world for Landz's users and Landz itself.\r\n\r\nJava 8 has been already in the bleeding edge front. Landz has great passion to push the front on top of next open Java, like GPU, cluster, big data side, or something like (security)rule engine...Nothing is impossible!\r\n\r\nBecause I am in a cold these days in my back hometown for Chine Spring Festival. So, I drop several important but uncompleted modules/components, like contracts, loggging, security, lambdabyte(type safe bytecode operation in Java, cool)... I think the current Landz has got a solid foundation for several high performance field usages. It is the time for inviting friends to come in. \r\n\r\nI am truely looking forward to working with all of your guys having the similiar ideas to challenge that mountain top together. Join us at [Landz's group](http://groups.google.com/d/forum/landz) or [contact me directly](mailto: jin.phd@gmail.com)(if you have private concerns). Finally, if you has idea to run Landz kernel or more with your business, you are contrbibuting to Landz already. I will provide my 0day help for you as possbile. Thannk you!\r\n\r\nA http module in z stack for self-hosting Landz's website is coming into the eye. I will replace the github page with Landz's true website.\r\n\r\nLet's keep rolling!\r\n\r\n\r\nJin Mingjian\r\n<br/>\r\n2014-01-31 ","google":"UA-47684607-1","note":"Don't delete this file! It's used internally to help with page regeneration."}